<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AT&amp;T&#39;s M2X C-MQTT LIBRARY: C (MQTT) M2X API Client</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AT&amp;T&#39;s M2X C-MQTT LIBRARY
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">C (MQTT) M2X API Client </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="http://m2x.att.com">AT&amp;T M2X</a> is a cloud-based fully managed time-series data storage service for network connected machine-to-machine (M2M) devices and the Internet of Things (IoT).</p>
<p>The <a href="https://m2x.att.com/developer/documentation/overview">AT&amp;T M2X API</a> provides all the needed operations and methods to connect your devices to AT&amp;T's M2X service. This library aims to provide a simple wrapper to interact with the AT&amp;T M2X API for <a href="http://www.open-std.org/jtc1/sc22/wg14/">C</a> using the <a href="http://mqtt.org">MQTT</a> protocol. Refer to the <a href="https://m2x.att.com/developer/documentation/glossary">Glossary of Terms</a> to understand the nomenclature used throughout this documentation.</p>
<h1>Getting Started </h1>
<ol type="1">
<li>Signup for an M2X Account: <a href="https://m2x.att.com/signup">https://m2x.att.com/signup</a></li>
<li>Obtain your <em>Master Key</em> from the Master Keys tab of your Account Settings: <a href="https://m2x.att.com/account">https://m2x.att.com/account</a></li>
<li>Create your first Device and copy its <em>Device ID</em>: <a href="https://m2x.att.com/devices">https://m2x.att.com/devices</a></li>
<li>Review the M2X API Documentation: <a href="https://m2x.att.com/developer/documentation/overview">https://m2x.att.com/developer/documentation/overview</a></li>
</ol>
<p>If you have questions about any M2X specific terms, please consult the M2X glossary: <a href="https://m2x.att.com/developer/documentation/glossary">https://m2x.att.com/developer/documentation/glossary</a></p>
<h1>Setup </h1>
<p>This library is written using <a href="http://en.wikipedia.org/wiki/ANSI_C">C99</a> standard. Any decent C compilers, including gcc and clang, can be used to compile the library. The only external dependencies needed are <a href="http://git.eclipse.org/c/paho/org.eclipse.paho.mqtt.embedded-c.git/">paho</a> for MQTT communications, and <a href="https://github.com/cesanta/frozen">frozen</a> for JSON parsing.</p>
<p>The library uses no dynamic memory allocation except for the JSON parser part in order to achieve maximum compatability with embedded boards.</p>
<p>To bulid the library and examples, use the following steps:</p>
<div class="fragment"><div class="line">$ git clone https://github.com/attm2x/m2x-c-mqtt.git</div><div class="line">$ cd m2x-c-mqtt</div><div class="line">$ make setup</div><div class="line">$ make</div><div class="line">$ make examples</div></div><!-- fragment --><p>The library can be found at <code>build/m2x.a</code>, while examples can be found at <code>build/examples</code>.</p>
<h1>API </h1>
<h2>Initialization</h2>
<p>To use this library, you need to create an M2X context object first:</p>
<div class="fragment"><div class="line">const char *key = &quot;&lt;Your M2X key&gt;&quot;;</div><div class="line">m2x_context ctx;</div><div class="line">m2x_open(key, &amp;ctx);</div></div><!-- fragment --><p>Notice there's no need to create the context object on the heap, dynamically memory allocation is not a requirement here.</p>
<h2>SSL support</h2>
<p>By default, this library implements SSL support via <a href="https://www.openssl.org/">OpenSSL</a>. However, you can also disable the SSL support completely:</p>
<div class="fragment"><div class="line">$ make SSL=false</div><div class="line">$ make examples SSL=false</div></div><!-- fragment --><p>It is also possible to build with SSL support, but turn it off for the current request. Just set <code>use_ssl</code> in <code><a class="el" href="structm2x__context.html">m2x_context</a></code> will do the trick.</p>
<p>For SSL connections, the default port used is <code>8883</code>, while non-SSL connections use <code>1883</code> port.</p>
<h2>Calling API functions</h2>
<p>All API functions will have the following type of signature:</p>
<div class="fragment"><div class="line">m2x_response m2x_some_api_function(m2x_context *ctx, const char *arg1, const char *arg2, ...);</div></div><!-- fragment --><p>Notice that this library wraps the MQTT communications completely: you don't need to do the MQTT connection manually, the library will take care of that for you. All you need to do is call the correct functions.</p>
<p>Depending the exact function in use, different number of arguments may be present. For example, below is a function used to list stream values of a device:</p>
<div class="fragment"><div class="line">m2x_response m2x_device_list_stream_values(m2x_context *ctx, const char *id, const char *name, const char *query);</div></div><!-- fragment --><p>It requires the context object, device ID, stream name and a query string. The query string is the same you would normally see in an HTTP request, like the following:</p>
<div class="fragment"><div class="line">max=100&amp;limit=10</div></div><!-- fragment --><p>We will talk about <code><a class="el" href="structm2x__response.html">m2x_response</a></code> in the next section.</p>
<p>Notice that there is no need to connect to MQTT broker before calling the API functions. The library will check if a connection is available first, and connect if necessary. By default, the connection will also be closed once the API request is fulfilled, however, there's another mode that will keep an MQTT connection open. We will talk about it later.</p>
<h2>Response object</h2>
<p>All API functions will return an <code><a class="el" href="structm2x__response.html">m2x_response</a></code> object. This object contains the status code, raw response as well as JSON-parsed response. The type of this object is as follows:</p>
<div class="fragment"><div class="line">typedef struct m2x_response {</div><div class="line">  int status;</div><div class="line"></div><div class="line">  char *raw;</div><div class="line">  int raw_length;</div><div class="line"></div><div class="line">  void *data;</div><div class="line">} m2x_response;</div></div><!-- fragment --><ul>
<li><code>status</code> contains the same status code as those you can see in an HTTP request</li>
<li><code>raw</code> contains the raw reply from the MQTT server(not necessarily NULL-terminated)</li>
<li><code>data</code> contains the reply from our JSON parser</li>
</ul>
<p>Though we use <a href="https://github.com/cesanta/frozen">frozen</a> as the library to parse JSON, we shall see later that it is even possible to plug-in another JSON parsing library of your choice. This is the reason that <code>data</code> has type <code>void *</code>: you can store anything you want here and cast it to the actual type later.</p>
<p>A handful of helpers are created for better usage of this object:</p>
<div class="fragment"><div class="line">int m2x_is_success(const m2x_response *response);</div><div class="line">int m2x_is_client_error(const m2x_response *response);</div><div class="line">int m2x_is_server_error(const m2x_response *response);</div><div class="line">int m2x_is_error(const m2x_response *response);</div><div class="line">void m2x_release_response(m2x_context *ctx, m2x_response *response);</div></div><!-- fragment --><p>What's worth mentioning here, is that <code>m2x_release_response</code> only frees the memory allocated in <code>data</code>. <code>raw</code> is pointing directly to the memory buffer in MQTT connection, which will be available until the next API call.</p>
<h2>Reading data</h2>
<p>By default, we use <a href="https://github.com/cesanta/frozen">frozen</a> to parse the JSON data. Below is an example of how you can read the values via frozen:</p>
<div class="fragment"><div class="line">// Simplified from the list_devices example</div><div class="line">m2x_response response;</div><div class="line">struct json_token *arr = NULL, *tok = NULL;</div><div class="line"></div><div class="line">response = m2x_device_list(&amp;ctx, &quot;&quot;);</div><div class="line">if (m2x_is_success(&amp;response)) {</div><div class="line">  arr = (struct json_token *) response.data;</div><div class="line">  tok = find_json_token(arr, &quot;body.total&quot;);</div><div class="line">  if (tok) {</div><div class="line">    printf(&quot;Total values: &quot;);</div><div class="line">    fwrite(tok-&gt;ptr, sizeof(char), tok-&gt;len, stdout);</div><div class="line">    printf(&quot;\n&quot;);</div><div class="line">  }</div><div class="line">}</div><div class="line">m2x_release_response(&amp;ctx, &amp;response);</div></div><!-- fragment --><p>Below is a sample reply that the code piece above is handling:</p>
<div class="fragment"><div class="line">{</div><div class="line">  &quot;id&quot;: &quot;3FAXPM6QDTBTPNFQ1LMWSQAABL0RK107&quot;,</div><div class="line">  &quot;status&quot;: 200,</div><div class="line">  &quot;body&quot;: {</div><div class="line">    &quot;total&quot;: 1,</div><div class="line">    &quot;pages&quot;: 1,</div><div class="line">    &quot;limit&quot;: 10,</div><div class="line">    &quot;current_page&quot;: 1,</div><div class="line">    &quot;devices&quot;: [</div><div class="line">      {</div><div class="line">        &quot;id&quot;: &quot;059c21d01876a31c8a85db65a8dad9c8&quot;,</div><div class="line">        &quot;url&quot;: &quot;http://api-m2x.att.com/v2/devices/059c21d01876a31c8a85db65a8dad9c8&quot;,</div><div class="line">        &quot;name&quot;: &quot;API Batch&quot;,</div><div class="line">        &quot;status&quot;: &quot;enabled&quot;,</div><div class="line">        &quot;serial&quot;: &quot;ABC1234&quot;,</div><div class="line">        &quot;tags&quot;: [],</div><div class="line">        &quot;location&quot;: {</div><div class="line">          &quot;name&quot;: &quot;room&quot;,</div><div class="line">          &quot;latitude&quot;: 10,</div><div class="line">          &quot;longitude&quot;: 12,</div><div class="line">          &quot;elevation&quot;: null,</div><div class="line">          &quot;timestamp&quot;: &quot;2013-12-31T02:23:40.000Z&quot;</div><div class="line">        },</div><div class="line">        &quot;visibility&quot;: &quot;public&quot;,</div><div class="line">        &quot;description&quot;: &quot;Created in API&quot;,</div><div class="line">        &quot;created&quot;: &quot;2013-12-31T01:32:00.000Z&quot;,</div><div class="line">        &quot;updated&quot;: &quot;2014-05-14T23:35:53.485Z&quot;,</div><div class="line">        &quot;key&quot;: &quot;fea432ba14239b79aaead32ca93565f8&quot;</div><div class="line">      }</div><div class="line">    ]</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h1>Options </h1>
<h2>Keepalive</h2>
<p>The default behaviour of this library is to create a new connection each time an API function is called, however, this can be changed by changing <code>keepalive</code> field in the context object to 1:</p>
<div class="fragment"><div class="line">m2x_context ctx;</div><div class="line">m2x_open(M2X_KEY, &amp;ctx);</div><div class="line">ctx.keepalive = 1;</div></div><!-- fragment --><p>In this case, the library will maintain a connection to MQTT, and reuse it each time.</p>
<p>NOTE: due to the protocol of MQTT, if you are using the keepalive option, you need to call <code>m2x_mqtt_yield</code> at certain periods(at least once per 10 seconds by default) to maintain the connection. In other words, you need to maintain such a loop:</p>
<div class="fragment"><div class="line">m2x_context ctx;</div><div class="line">while (true) {</div><div class="line">  // perform some other action</div><div class="line">  m2x_mqtt_yield(&amp;ctx)</div><div class="line">}</div></div><!-- fragment --><p>Otherwise, the connection will be lost at certain time, and errors will occur.</p>
<h2>JSON</h2>
<p>By default, we use <a href="https://github.com/cesanta/frozen">frozen</a>, but you can also plug-in your favourite JSON parser to handle the requests. All you need to do is implement this function:</p>
<div class="fragment"><div class="line">typedef struct m2x_json_result {</div><div class="line">  int status_code;</div><div class="line">  void *data;</div><div class="line">} m2x_json_result;</div><div class="line"></div><div class="line">typedef enum m2x_json_status {</div><div class="line">  M2X_JSON_OK = 0,</div><div class="line">  M2X_JSON_INVALID = -1,</div><div class="line">  M2X_JSON_ID_NOT_MATCH = -2,</div><div class="line">} m2x_json_status;</div><div class="line"></div><div class="line">typedef m2x_json_status (*m2x_json_parser) (const char *, int,</div><div class="line">                                            const char *, int,</div><div class="line">                                            m2x_json_result *);</div></div><!-- fragment --><p>The function takes the response JSON string(not NULL-terminated), and the designated message ID(also not NULL-terminated), you need to test the following things:</p>
<ol type="1">
<li>Is the JSON string valid?</li>
<li>Is the message ID obtained in the JSON string the same as the provided JSON string?</li>
</ol>
<p>If the answers to both questions here are yes, we have a valid response here, you can fill the <code><a class="el" href="structm2x__json__result.html">m2x_json_result</a></code> with the status code and the returned data. Notice the <code>data</code> returned here will become the coresponding <code>data</code> field in <code><a class="el" href="structm2x__response.html">m2x_response</a></code> object.</p>
<p>After you implement this function, you can set it to the <code>json_parser</code> field in <code><a class="el" href="structm2x__context.html">m2x_context</a></code> object, the library will then use your specified JSON parser to parse the result!</p>
<p>By default, we expect the <code>data</code> pointer is pointed to a piece of memory allocated using <code>malloc</code>, and that we can use <code>free</code> to release the memory. In fact, this is also the only place in the library that uses dynamic memory allocation. However, if your JSON parser is working in another way (for example, if you use static memory, or use multiple malloc), you can implement the function used to release memory:</p>
<div class="fragment"><div class="line">typedef void (*m2x_json_releaser) (void *);</div></div><!-- fragment --><p>Setting this function to <code>json_releaser</code> field in <code><a class="el" href="structm2x__context.html">m2x_context</a></code>, then the library will use your new memory releaser to do the job.</p>
<h2>Preparing data for writer functions</h2>
<p>You can also send data to M2X service using this library. The following function can be used to update stream values:</p>
<div class="fragment"><div class="line">m2x_response m2x_device_update_stream(m2x_context *ctx, const char *id, const char *name, const char *data);</div></div><!-- fragment --><p><code>id</code> and <code>name</code> are just plain strings representing device ID and stream name respectively. The <code>data</code> field here is actually a JSON string containing the data to send. We use plain <code>const char *</code> type for maximum flexibility. You can you any JSON serializer that you like to do the job.</p>
<p>Notice the packed <code>frozen</code> library also has a JSON serializer, you can refer to <a href="https://github.com/attm2x/m2x-c-mqtt/blob/master/examples/create_device.c#L33">our example</a> and the https://github.com/cesanta/frozen/blob/master/README.md "README" of frozen for how this is working.</p>
<p>Last but not least, you can always use <code>sprintf</code> to prepare the JSON string if it is not very complicated.</p>
<h1>License </h1>
<p>The M2X C (MQTT) Client is available under the MIT license. See the LICENSE file for more information. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
